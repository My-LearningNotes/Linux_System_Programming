线程终止
========

如果进程中的任一线程调用了\ ``exit``, ``_Exit``, ``_exit``, 那么整个进程就会终止.
与此类似, 如果信号的默认动作是终止进程, 那么, 把该信号发送到线程会终止整个进程.

单个线程可以通过以下三种方式退出, 在不终止整个进程的情况下停止它的控制流:

 * 线程只是从启动例程中返回, 返回值是线程的退出码(线程执行完退出);
 * 线程可以被同一进程中的其他线程取消(\ ``pthread_cancel``\ 函数);
 * 在线程中调用\ ``pthread_exit``\ 函数，主动退出.


``pthread_exit``
----------------

在一个线程中, 调用\ ``pthread_exit``\ 函数, 使当前线程退出, 线程退出时, 需要设定线程的退出码.

函数原型:

    .. code-block:: c
        :emphasize-lines: 1

        int pthread_exit(void *rval_ptr);

        # rval_ptr是一个无类型指针, 指向表示当前线程退出码的结构体;


``pthread_detach``
------------------

POSIX线程的一个特点是: 除非线程是被分离了的, 否则在线程退出时, 它的资源是不会被释放的;
调用\ ``pthread_detach``\ 函数来分离线程;

.. note::

    可以这么理解，默认状况下，子线程是和进程绑定在一起，子线程退出时并不会释放该线程的资源;
    可以将线程设定为detach状态，当该线程退出时，释放其资源;

函数原型:

    .. code-block:: c
        :emphasize-lines: 1

        int pthread_detach(pthread_t thread);

被分离的线程退出时不会报告它们的状态(没有线程的退出码).


``pthread_join``
----------------

``pthread_join``\ 函数用来等待一个线程的退出, 并获取退出线程的退出码.
